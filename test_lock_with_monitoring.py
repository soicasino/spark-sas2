#!/usr/bin/env python3\n\"\"\"\nLock/Unlock Test with Real-time Status Monitoring\nTests the original lock/unlock commands while monitoring machine status\n\"\"\"\n\nimport time\nimport threading\nimport requests\nimport json\nfrom sas_communicator import SASCommunicator\nfrom config_manager import ConfigManager\n\nclass LockUnlockMonitor:\n    def __init__(self):\n        self.running = False\n        self.poll_thread = None\n        self.communicator = None\n        self.api_base = \"http://10.0.0.200:8000/api\"\n        \n    def get_machine_status(self):\n        \"\"\"Get current machine status via API\"\"\"\n        try:\n            response = requests.get(f\"{self.api_base}/machine/status\", timeout=5)\n            if response.status_code == 200:\n                data = response.json()\n                if data.get('success'):\n                    return data.get('data', {})\n        except Exception as e:\n            print(f\"‚ùå Error getting status: {e}\")\n        return None\n    \n    def print_status(self, label=\"Status\"):\n        \"\"\"Print current machine status\"\"\"\n        status = self.get_machine_status()\n        if status:\n            lock_status = status.get('lock_status', 'Unknown')\n            aft_status = status.get('aft_status', 'Unknown')\n            is_locked = status.get('is_locked', 'Unknown')\n            available_transfers = status.get('available_transfers', 'Unknown')\n            \n            print(f\"\\nüìä {label}:\")\n            print(f\"   Lock Status: {lock_status} ({'üîí LOCKED' if lock_status == 'FF' else 'üîì UNLOCKED' if lock_status == '00' else 'üîÑ PARTIAL'})\")\n            print(f\"   AFT Status: {aft_status}\")\n            print(f\"   Is Locked: {is_locked}\")\n            print(f\"   Available Transfers: {available_transfers}\")\n            \n            return lock_status\n        else:\n            print(f\"\\n‚ùå {label}: Could not retrieve status\")\n            return None\n    \n    def start_polling(self):\n        \"\"\"Start background polling thread\"\"\"\n        self.running = True\n        self.poll_thread = threading.Thread(target=self._poll_loop, daemon=True)\n        self.poll_thread.start()\n        print(\"‚úÖ Background polling started\")\n        \n    def stop_polling(self):\n        \"\"\"Stop background polling\"\"\"\n        self.running = False\n        if self.poll_thread:\n            self.poll_thread.join(timeout=2)\n        print(\"‚úÖ Background polling stopped\")\n        \n    def _poll_loop(self):\n        \"\"\"Background polling loop\"\"\"\n        while self.running:\n            try:\n                if self.communicator and self.communicator.is_port_open:\n                    # Simple polling - just keep connection alive\n                    time.sleep(0.1)\n                else:\n                    time.sleep(0.5)\n            except Exception as e:\n                if self.running:\n                    print(f\"Polling error: {e}\")\n                time.sleep(1)\n\n    def send_command_direct(self, command_name, command_hex):\n        \"\"\"Send a SAS command directly\"\"\"\n        try:\n            print(f\"\\nüîß [{command_name}] Sending: {command_hex}\")\n            \n            # Send the command using the communicator's direct method\n            result = self.communicator.sas_send_command_with_queue(\n                command_name, \n                command_hex, \n                0  # do_save_db parameter\n            )\n            \n            print(f\"   Command sent, waiting for effect...\")\n            time.sleep(1)  # Give time for command to take effect\n            \n            return True\n                \n        except Exception as e:\n            print(f\"   ‚ùå Error: {e}\")\n            return False\n\n    def test_unlock_sequence(self):\n        \"\"\"Test unlock with multiple approaches\"\"\"\n        print(\"\\nüîì === COMPREHENSIVE UNLOCK TEST ===\")\n        \n        # Method 1: Original unlock command (twice)\n        print(\"\\n--- Method 1: Original Unlock Command (0102CA3A) ---\")\n        initial_status = self.print_status(\"Before Unlock\")\n        \n        # Send unlock command twice like in original code\n        self.send_command_direct(\"UNLOCK_1\", \"0102CA3A\")\n        time.sleep(0.1)\n        self.send_command_direct(\"UNLOCK_2\", \"0102CA3A\")\n        time.sleep(2)\n        \n        after_unlock = self.print_status(\"After Original Unlock\")\n        \n        # Check if status changed\n        if initial_status != after_unlock:\n            print(\"‚úÖ Status changed after unlock!\")\n        else:\n            print(\"‚ùå No status change detected\")\n            \n        return after_unlock\n    \n    def test_lock_sequence(self):\n        \"\"\"Test lock command\"\"\"\n        print(\"\\nüîí === LOCK TEST ===\")\n        \n        initial_status = self.print_status(\"Before Lock\")\n        \n        # Send lock command\n        self.send_command_direct(\"LOCK\", \"01015108\")\n        time.sleep(2)\n        \n        after_lock = self.print_status(\"After Lock\")\n        \n        # Check if status changed\n        if initial_status != after_lock:\n            print(\"‚úÖ Status changed after lock!\")\n        else:\n            print(\"‚ùå No status change detected\")\n            \n        return after_lock\n    \n    def test_alternative_unlocks(self):\n        \"\"\"Test alternative unlock approaches\"\"\"\n        print(\"\\nüîß === ALTERNATIVE UNLOCK METHODS ===\")\n        \n        # Method 2: Try different unlock variations\n        unlock_commands = [\n            (\"UNLOCK_ALT_1\", \"01020000\"),  # Simple unlock without CRC\n            (\"UNLOCK_ALT_2\", \"010200CA3A\"),  # With extra bytes\n            (\"UNLOCK_ALT_3\", \"01020001\"),  # Different parameter\n        ]\n        \n        for cmd_name, cmd_hex in unlock_commands:\n            print(f\"\\n--- Testing {cmd_name}: {cmd_hex} ---\")\n            before = self.print_status(f\"Before {cmd_name}\")\n            \n            self.send_command_direct(cmd_name, cmd_hex)\n            time.sleep(2)\n            \n            after = self.print_status(f\"After {cmd_name}\")\n            \n            if before != after:\n                print(f\"‚úÖ {cmd_name} caused status change!\")\n                return True\n            else:\n                print(f\"‚ùå {cmd_name} - no change\")\n        \n        return False\n    \n    def run_comprehensive_test(self):\n        \"\"\"Run comprehensive lock/unlock test with monitoring\"\"\"\n        print(\"=== Lock/Unlock Test with Real-time Monitoring ===\")\n        print(\"This test monitors machine status while testing lock/unlock commands\")\n        \n        # Initialize SAS communication\n        config = ConfigManager()\n        port = \"/dev/ttyUSB1\"\n        \n        print(f\"\\nUsing port: {port}\")\n        print(\"Opening SAS port...\")\n        \n        self.communicator = SASCommunicator(port, config)\n        \n        if not self.communicator.open_port():\n            print(\"‚ùå Failed to open SAS port\")\n            return False\n        \n        print(\"‚úÖ SAS port opened successfully\")\n        \n        # Start background polling\n        self.start_polling()\n        \n        try:\n            print(\"\\nWaiting for communication to stabilize...\")\n            time.sleep(3)\n            \n            # Initial status\n            print(\"\\n\" + \"=\"*50)\n            initial_status = self.print_status(\"INITIAL STATUS\")\n            print(\"=\"*50)\n            \n            # Test unlock first\n            unlock_status = self.test_unlock_sequence()\n            \n            # If unlock didn't work, try alternatives\n            if unlock_status == 'FF':  # Still locked\n                print(\"\\n‚ö†Ô∏è  Original unlock didn't work, trying alternatives...\")\n                self.test_alternative_unlocks()\n            \n            # Test lock (if machine got unlocked)\n            current_status = self.print_status(\"Current Status\")\n            if current_status != 'FF':  # If not fully locked\n                lock_status = self.test_lock_sequence()\n                \n                # Try unlock again after lock\n                if lock_status == 'FF':  # If successfully locked\n                    print(\"\\nüîÑ Testing unlock after successful lock...\")\n                    self.test_unlock_sequence()\n            \n            # Final status\n            print(\"\\n\" + \"=\"*50)\n            final_status = self.print_status(\"FINAL STATUS\")\n            print(\"=\"*50)\n            \n            # Summary\n            print(\"\\nüìã === TEST SUMMARY ===\")\n            print(f\"Initial Status: {initial_status}\")\n            print(f\"Final Status: {final_status}\")\n            \n            if initial_status != final_status:\n                print(\"‚úÖ Machine status changed during testing!\")\n                print(\"   This indicates the commands are having some effect.\")\n            else:\n                print(\"‚ùå No status changes detected\")\n                print(\"   The machine may require different commands or conditions.\")\n                \n            return True\n            \n        finally:\n            print(\"\\nCleaning up...\")\n            self.stop_polling()\n            if self.communicator:\n                self.communicator.close_port()\n            print(\"‚úÖ Port closed\")\n\nif __name__ == \"__main__\":\n    tester = LockUnlockMonitor()\n    tester.run_comprehensive_test()" 